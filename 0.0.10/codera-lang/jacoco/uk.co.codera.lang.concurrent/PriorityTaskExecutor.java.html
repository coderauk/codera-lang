<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PriorityTaskExecutor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codera-lang</a> &gt; <a href="index.source.html" class="el_package">uk.co.codera.lang.concurrent</a> &gt; <span class="el_source">PriorityTaskExecutor.java</span></div><h1>PriorityTaskExecutor.java</h1><pre class="source lang-java linenums">package uk.co.codera.lang.concurrent;

import java.util.Comparator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Executor;

import uk.co.codera.lang.concurrent.Tasks.CancellableTask;
import uk.co.codera.lang.concurrent.Tasks.CancellingTask;

/**
 * &lt;p&gt;
 * A task executor that will process tasks in priority order. It allows tasks
 * that overtake to cancel other tasks in the queue.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Currently the implementation only allows for serial execution of tasks, i.e.
 * it is single threaded. This is to prevent tasks with the same correlation id
 * being processed concurrently. In future an executor that allows multiple
 * threads whilst keeping tasks with the same correlation id in order may be
 * provided.
 * &lt;/p&gt;
 * 
 * @author andystewart
 */
public class PriorityTaskExecutor {

    private final Executor executor;
    private final ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks;
    private final RunPolicyFactory runPolicies;
    private final TaskCallback callback;

<span class="fc" id="L33">    private PriorityTaskExecutor(Builder builder) {</span>
<span class="fc" id="L34">        this.executor = SequencedPriorityExecutor.singleThreadedExecutor(new PriorityTaskComparator(</span>
<span class="fc" id="L35">                builder.normalTaskBehaviour));</span>
<span class="fc" id="L36">        this.cancelledTasks = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L37">        this.runPolicies = new RunPolicyFactory(this.cancelledTasks);</span>
<span class="fc" id="L38">        this.callback = builder.callback;</span>
<span class="fc" id="L39">    }</span>

    public static Builder aTaskExecutor() {
<span class="fc" id="L42">        return new Builder();</span>
    }

    public void submit(Task task) {
<span class="fc" id="L46">        TaskRunner taskRunner = new TaskRunner(runPolicyFor(task), task, this.callback);</span>
<span class="fc" id="L47">        this.executor.execute(taskRunner);</span>
<span class="fc" id="L48">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private RunPolicy&lt;Task&gt; runPolicyFor(Task task) {
<span class="fc" id="L52">        return (RunPolicy&lt;Task&gt;) this.runPolicies.policyFor(task);</span>
    }

    public static class Builder {

<span class="fc" id="L57">        private NormalTaskBehaviour normalTaskBehaviour = NormalTaskBehaviour.DOES_NOT_OVERTAKE;</span>
<span class="fc" id="L58">        private TaskCallback callback = new TaskCallbackAdapter();</span>

        private Builder() {
<span class="fc" id="L61">            super();</span>
<span class="fc" id="L62">        }</span>

        public Builder allowNormalTasksToOvertakeCancellableTasks() {
<span class="fc" id="L65">            return normalTaskBehaviour(NormalTaskBehaviour.OVERTAKE_CANCELLABLE);</span>
        }

        public Builder allowNormalTasksToOvertakeAllTasks() {
<span class="fc" id="L69">            return normalTaskBehaviour(NormalTaskBehaviour.OVERTAKE_ALL);</span>
        }

        public Builder with(TaskCallback callback) {
<span class="fc" id="L73">            this.callback = callback;</span>
<span class="fc" id="L74">            return this;</span>
        }

        private Builder normalTaskBehaviour(NormalTaskBehaviour behaviour) {
<span class="fc" id="L78">            this.normalTaskBehaviour = behaviour;</span>
<span class="fc" id="L79">            return this;</span>
        }

        public PriorityTaskExecutor build() {
<span class="fc" id="L83">            return new PriorityTaskExecutor(this);</span>
        }
    }

<span class="pc" id="L87">    private enum NormalTaskBehaviour {</span>
<span class="fc" id="L88">        DOES_NOT_OVERTAKE, OVERTAKE_CANCELLABLE, OVERTAKE_ALL;</span>
    }

    private static class PriorityTaskComparator implements Comparator&lt;Runnable&gt; {

        private final NormalTaskBehaviour normalTaskBehaviour;

<span class="fc" id="L95">        public PriorityTaskComparator(NormalTaskBehaviour normalTaskBehaviour) {</span>
<span class="fc" id="L96">            this.normalTaskBehaviour = normalTaskBehaviour;</span>
<span class="fc" id="L97">        }</span>

        @Override
        public int compare(Runnable o1, Runnable o2) {
<span class="fc" id="L101">            return priority(o2).compareTo(priority(o1));</span>
        }

        private Integer priority(Runnable o) {
<span class="fc" id="L105">            Class&lt;?&gt; clazz = ((TaskRunner) o).task.getClass();</span>

<span class="fc bfc" id="L107" title="All 2 branches covered.">            if (clazz == CancellableTask.class) {</span>
<span class="fc" id="L108">                return 0;</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            } else if (clazz == CancellingTask.class) {</span>
<span class="fc" id="L110">                return 1;</span>
            }
<span class="fc" id="L112">            return this.normalTaskBehaviour.ordinal();</span>
        }
    }

    private static class TaskRunner implements Runnable {

        private final RunPolicy&lt;Task&gt; runPolicy;
        private final Task task;
        private final TaskCallback callback;

<span class="fc" id="L122">        private TaskRunner(RunPolicy&lt;Task&gt; runPolicy, Task task, TaskCallback callback) {</span>
<span class="fc" id="L123">            this.runPolicy = runPolicy;</span>
<span class="fc" id="L124">            this.task = task;</span>
<span class="fc" id="L125">            this.callback = callback;</span>
<span class="fc" id="L126">        }</span>

        @Override
        public void run() {
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (this.runPolicy.shouldRun(this.task)) {</span>
                try {
<span class="fc" id="L132">                    this.task.execute();</span>
<span class="fc" id="L133">                    this.callback.onTaskExecuted(this.task);</span>
<span class="fc" id="L134">                } catch (RuntimeException e) {</span>
<span class="fc" id="L135">                    this.callback.onTaskFailure(this.task, e);</span>
<span class="fc" id="L136">                }</span>
            } else {
<span class="fc" id="L138">                this.callback.onTaskCancelled(this.task);</span>
            }
<span class="fc" id="L140">        }</span>
    }

    private class RunPolicyFactory {

        private final ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks;

<span class="fc" id="L147">        private RunPolicyFactory(ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks) {</span>
<span class="fc" id="L148">            this.cancelledTasks = cancelledTasks;</span>
<span class="fc" id="L149">        }</span>

        private RunPolicy&lt;?&gt; policyFor(Task task) {
<span class="fc" id="L152">            Class&lt;? extends Task&gt; clazz = task.getClass();</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">            if (clazz == CancellableTask.class) {</span>
<span class="fc" id="L154">                return new CheckNotCancelled(this.cancelledTasks);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            } else if (clazz == CancellingTask.class) {</span>
<span class="fc" id="L156">                return new RecordsCancellation(this.cancelledTasks);</span>
            }
<span class="fc" id="L158">            return new AlwaysRun();</span>
        }
    }

    @FunctionalInterface
    private interface RunPolicy&lt;T extends Task&gt; {
        boolean shouldRun(T task);
    }

<span class="fc" id="L167">    private class AlwaysRun implements RunPolicy&lt;Task&gt; {</span>
        @Override
        public boolean shouldRun(Task task) {
<span class="fc" id="L170">            return true;</span>
        }
    }

    private class RecordsCancellation implements RunPolicy&lt;CancellingTask&gt; {

        private final ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks;

<span class="fc" id="L178">        public RecordsCancellation(ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks) {</span>
<span class="fc" id="L179">            this.cancelledTasks = cancelledTasks;</span>
<span class="fc" id="L180">        }</span>

        @Override
        public boolean shouldRun(CancellingTask task) {
<span class="fc" id="L184">            this.cancelledTasks.put(task.getCorrelationId(), task.getSequence());</span>
<span class="fc" id="L185">            return true;</span>
        }
    }

    private class CheckNotCancelled implements RunPolicy&lt;CancellableTask&gt; {

        private final ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks;

<span class="fc" id="L193">        public CheckNotCancelled(ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks) {</span>
<span class="fc" id="L194">            this.cancelledTasks = cancelledTasks;</span>
<span class="fc" id="L195">        }</span>

        @Override
        public boolean shouldRun(CancellableTask task) {
<span class="fc" id="L199">            Object correlationId = task.getCorrelationId();</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (this.cancelledTasks.containsKey(correlationId)) {</span>
<span class="fc" id="L201">                boolean reachedCancelledSequence = currentTaskSequenceExceededCancelledSequence(task, correlationId);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                if (reachedCancelledSequence) {</span>
<span class="fc" id="L203">                    this.cancelledTasks.remove(correlationId);</span>
                }
<span class="fc" id="L205">                return reachedCancelledSequence;</span>
            }
<span class="fc" id="L207">            return true;</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        private boolean currentTaskSequenceExceededCancelledSequence(CancellableTask task, Object correlationId) {
<span class="fc" id="L212">            Comparable&lt;?&gt; cancellingSequence = this.cancelledTasks.get(correlationId);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            return ((Comparable&lt;Object&gt;) task.getSequence()).compareTo((Comparable&lt;Object&gt;) cancellingSequence) &gt; 0;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>