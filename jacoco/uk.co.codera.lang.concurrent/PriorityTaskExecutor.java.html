<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PriorityTaskExecutor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codera-lang</a> &gt; <a href="index.source.html" class="el_package">uk.co.codera.lang.concurrent</a> &gt; <span class="el_source">PriorityTaskExecutor.java</span></div><h1>PriorityTaskExecutor.java</h1><pre class="source lang-java linenums">package uk.co.codera.lang.concurrent;

import java.util.Comparator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Executor;

import uk.co.codera.lang.concurrent.Tasks.CancellableTask;
import uk.co.codera.lang.concurrent.Tasks.CancellingTask;

/**
 * &lt;p&gt;
 * A task executor that will process tasks in priority order. It allows tasks
 * that overtake to cancel other tasks in the queue.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Currently the implementation only allows for serial execution of tasks, i.e.
 * it is single threaded. This is to prevent tasks with the same correlation id
 * being processed concurrently. In future an executor that allows multiple
 * threads whilst keeping tasks with the same correlation id in order may be
 * provided.
 * &lt;/p&gt;
 * 
 * @author andystewart
 */
public class PriorityTaskExecutor {

    private final Executor executor;
    private final ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks;
    private final RunPolicyFactory runPolicies;

<span class="fc" id="L32">    private PriorityTaskExecutor(Builder builder) {</span>
<span class="fc" id="L33">        this.executor = SequencedPriorityExecutor.singleThreadedExecutor(new PriorityTaskComparator(</span>
<span class="fc" id="L34">                builder.normalTaskBehaviour));</span>
<span class="fc" id="L35">        this.cancelledTasks = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L36">        this.runPolicies = new RunPolicyFactory(this.cancelledTasks);</span>
<span class="fc" id="L37">    }</span>

    public static Builder aTaskExecutor() {
<span class="fc" id="L40">        return new Builder();</span>
    }

    public void submit(Task task) {
<span class="fc" id="L44">        this.executor.execute(new TaskRunner(runPolicyFor(task), task));</span>
<span class="fc" id="L45">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private RunPolicy&lt;Task&gt; runPolicyFor(Task task) {
<span class="fc" id="L49">        return (RunPolicy&lt;Task&gt;) this.runPolicies.policyFor(task);</span>
    }

    public static class Builder {

<span class="fc" id="L54">        private NormalTaskBehaviour normalTaskBehaviour = NormalTaskBehaviour.DOES_NOT_OVERTAKE;</span>

        private Builder() {
<span class="fc" id="L57">            super();</span>
<span class="fc" id="L58">        }</span>

        public Builder allowNormalTasksToOvertakeCancellableTasks() {
<span class="fc" id="L61">            return normalTaskBehaviour(NormalTaskBehaviour.OVERTAKE_CANCELLABLE);</span>
        }

        public Builder allowNormalTasksToOvertakeAllTasks() {
<span class="fc" id="L65">            return normalTaskBehaviour(NormalTaskBehaviour.OVERTAKE_ALL);</span>
        }

        private Builder normalTaskBehaviour(NormalTaskBehaviour behaviour) {
<span class="fc" id="L69">            this.normalTaskBehaviour = behaviour;</span>
<span class="fc" id="L70">            return this;</span>
        }

        public PriorityTaskExecutor build() {
<span class="fc" id="L74">            return new PriorityTaskExecutor(this);</span>
        }
    }

<span class="pc" id="L78">    private enum NormalTaskBehaviour {</span>
<span class="fc" id="L79">        DOES_NOT_OVERTAKE, OVERTAKE_CANCELLABLE, OVERTAKE_ALL;</span>
    }

    private static class PriorityTaskComparator implements Comparator&lt;Runnable&gt; {

        private final NormalTaskBehaviour normalTaskBehaviour;

<span class="fc" id="L86">        public PriorityTaskComparator(NormalTaskBehaviour normalTaskBehaviour) {</span>
<span class="fc" id="L87">            this.normalTaskBehaviour = normalTaskBehaviour;</span>
<span class="fc" id="L88">        }</span>

        @Override
        public int compare(Runnable o1, Runnable o2) {
<span class="fc" id="L92">            return priority(o2).compareTo(priority(o1));</span>
        }

        private Integer priority(Runnable o) {
<span class="fc" id="L96">            Class&lt;?&gt; clazz = ((TaskRunner) o).task.getClass();</span>

<span class="fc bfc" id="L98" title="All 2 branches covered.">            if (clazz == CancellableTask.class) {</span>
<span class="fc" id="L99">                return 0;</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">            } else if (clazz == CancellingTask.class) {</span>
<span class="fc" id="L101">                return 1;</span>
            }
<span class="fc" id="L103">            return this.normalTaskBehaviour.ordinal();</span>
        }
    }

    private static class TaskRunner implements Runnable {

        private final RunPolicy&lt;Task&gt; runPolicy;
        private final Task task;

<span class="fc" id="L112">        private TaskRunner(RunPolicy&lt;Task&gt; runPolicy, Task task) {</span>
<span class="fc" id="L113">            this.runPolicy = runPolicy;</span>
<span class="fc" id="L114">            this.task = task;</span>
<span class="fc" id="L115">        }</span>

        @Override
        public void run() {
<span class="fc bfc" id="L119" title="All 2 branches covered.">            if (this.runPolicy.shouldRun(this.task)) {</span>
<span class="fc" id="L120">                this.task.execute();</span>
            }
<span class="fc" id="L122">        }</span>
    }

    private class RunPolicyFactory {

        private final ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks;

<span class="fc" id="L129">        private RunPolicyFactory(ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks) {</span>
<span class="fc" id="L130">            this.cancelledTasks = cancelledTasks;</span>
<span class="fc" id="L131">        }</span>

        private RunPolicy&lt;?&gt; policyFor(Task task) {
<span class="fc" id="L134">            Class&lt;? extends Task&gt; clazz = task.getClass();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if (clazz == CancellableTask.class) {</span>
<span class="fc" id="L136">                return new CheckNotCancelled(this.cancelledTasks);</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            } else if (clazz == CancellingTask.class) {</span>
<span class="fc" id="L138">                return new RecordsCancellation(this.cancelledTasks);</span>
            }
<span class="fc" id="L140">            return new AlwaysRun();</span>
        }
    }

    @FunctionalInterface
    private interface RunPolicy&lt;T extends Task&gt; {
        boolean shouldRun(T task);
    }

<span class="fc" id="L149">    private class AlwaysRun implements RunPolicy&lt;Task&gt; {</span>
        @Override
        public boolean shouldRun(Task task) {
<span class="fc" id="L152">            return true;</span>
        }
    }

    private class RecordsCancellation implements RunPolicy&lt;CancellingTask&gt; {

        private final ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks;

<span class="fc" id="L160">        public RecordsCancellation(ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks) {</span>
<span class="fc" id="L161">            this.cancelledTasks = cancelledTasks;</span>
<span class="fc" id="L162">        }</span>

        @Override
        public boolean shouldRun(CancellingTask task) {
<span class="fc" id="L166">            this.cancelledTasks.put(task.getCorrelationId(), task.getSequence());</span>
<span class="fc" id="L167">            return true;</span>
        }
    }

    private class CheckNotCancelled implements RunPolicy&lt;CancellableTask&gt; {

        private final ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks;

<span class="fc" id="L175">        public CheckNotCancelled(ConcurrentMap&lt;Object, Comparable&lt;?&gt;&gt; cancelledTasks) {</span>
<span class="fc" id="L176">            this.cancelledTasks = cancelledTasks;</span>
<span class="fc" id="L177">        }</span>

        @Override
        public boolean shouldRun(CancellableTask task) {
<span class="fc" id="L181">            Object correlationId = task.getCorrelationId();</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (this.cancelledTasks.containsKey(correlationId)) {</span>
<span class="fc" id="L183">                boolean reachedCancelledSequence = currentTaskSequenceExceededCancelledSequence(task, correlationId);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                if (reachedCancelledSequence) {</span>
<span class="fc" id="L185">                    this.cancelledTasks.remove(correlationId);</span>
                }
<span class="fc" id="L187">                return reachedCancelledSequence;</span>
            }
<span class="fc" id="L189">            return true;</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        private boolean currentTaskSequenceExceededCancelledSequence(CancellableTask task, Object correlationId) {
<span class="fc" id="L194">            Comparable&lt;?&gt; cancellingSequence = this.cancelledTasks.get(correlationId);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            return ((Comparable&lt;Object&gt;) task.getSequence()).compareTo((Comparable&lt;Object&gt;) cancellingSequence) &gt; 0;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>