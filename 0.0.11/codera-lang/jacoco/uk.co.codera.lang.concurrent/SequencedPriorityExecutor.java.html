<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SequencedPriorityExecutor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codera-lang</a> &gt; <a href="index.source.html" class="el_package">uk.co.codera.lang.concurrent</a> &gt; <span class="el_source">SequencedPriorityExecutor.java</span></div><h1>SequencedPriorityExecutor.java</h1><pre class="source lang-java linenums">package uk.co.codera.lang.concurrent;

import java.util.Comparator;
import java.util.concurrent.Executor;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

/**
 * &lt;p&gt;
 * An implementation of the {@link Executor} that is backed by a
 * {@link PriorityBlockingQueue}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * One drawback of the backing queue is jobs with equal priority are not
 * guaranteed to be run in any particular order. This implementation ensures
 * they are run in the order submitted by assigning a sequence number when the
 * job is offered for execution. This is then used in conjunction with the
 * priority to determine which task should be executed next.
 * &lt;/p&gt;
 * 
 * @author andystewart
 */
public class SequencedPriorityExecutor implements Executor {

    public static final int INITIAL_QUEUE_CAPACITY = 1000;
    private static final int SINGLE_THREAD = 1;

    private final Executor underlyingExecutor;
    private final AtomicLong sequenceNumber;

<span class="fc" id="L33">    private SequencedPriorityExecutor(int numberThreads, Comparator&lt;Runnable&gt; comparator) {</span>
<span class="fc" id="L34">        this.underlyingExecutor = threadPoolExecutor(numberThreads, comparator);</span>
<span class="fc" id="L35">        this.sequenceNumber = new AtomicLong(0);</span>
<span class="fc" id="L36">    }</span>

    public static Executor singleThreadedExecutor(Comparator&lt;Runnable&gt; comparator) {
<span class="fc" id="L39">        return new SequencedPriorityExecutor(SINGLE_THREAD, comparator);</span>
    }

    @Override
    public void execute(Runnable command) {
<span class="fc" id="L44">        SequencedRunnable sequencedCommand = new SequencedRunnable(command, this.sequenceNumber.getAndIncrement());</span>
<span class="fc" id="L45">        this.underlyingExecutor.execute(sequencedCommand);</span>
<span class="fc" id="L46">    }</span>

    private ThreadPoolExecutor threadPoolExecutor(int numberThreads, Comparator&lt;Runnable&gt; comparator) {
<span class="fc" id="L49">        return new ThreadPoolExecutor(numberThreads, numberThreads, 0L, TimeUnit.MILLISECONDS,</span>
<span class="fc" id="L50">                blockingQueue(comparator));</span>
    }

    private PriorityBlockingQueue&lt;Runnable&gt; blockingQueue(Comparator&lt;Runnable&gt; comparator) {
<span class="fc" id="L54">        return new PriorityBlockingQueue&lt;&gt;(INITIAL_QUEUE_CAPACITY, new SequencedPriorityComparator(comparator));</span>
    }

    private static class SequencedRunnable implements Runnable {
        private final Runnable underlyingRunnable;
        private final Long sequenceNumber;

<span class="fc" id="L61">        private SequencedRunnable(Runnable command, long sequenceNumber) {</span>
<span class="fc" id="L62">            this.underlyingRunnable = command;</span>
<span class="fc" id="L63">            this.sequenceNumber = Long.valueOf(sequenceNumber);</span>
<span class="fc" id="L64">        }</span>

        @SuppressWarnings(&quot;squid:S1217&quot;)
        @Override
        public void run() {
<span class="fc" id="L69">            this.underlyingRunnable.run();</span>
<span class="fc" id="L70">        }</span>

        public Long getSequenceNumber() {
<span class="fc" id="L73">            return sequenceNumber;</span>
        }

        public Runnable getUnderlyingRunnable() {
<span class="fc" id="L77">            return this.underlyingRunnable;</span>
        }
    }

    private static class SequencedPriorityComparator implements Comparator&lt;Runnable&gt; {

        private final Comparator&lt;Runnable&gt; priorityComparator;

<span class="fc" id="L85">        private SequencedPriorityComparator(Comparator&lt;Runnable&gt; priorityComparator) {</span>
<span class="fc" id="L86">            this.priorityComparator = priorityComparator;</span>
<span class="fc" id="L87">        }</span>

        @Override
        public int compare(Runnable o1, Runnable o2) {
<span class="fc" id="L91">            SequencedRunnable s1 = (SequencedRunnable) o1;</span>
<span class="fc" id="L92">            SequencedRunnable s2 = (SequencedRunnable) o2;</span>
<span class="fc" id="L93">            int priority = this.priorityComparator.compare(s1.getUnderlyingRunnable(), s2.getUnderlyingRunnable());</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">            if (priority == 0) {</span>
<span class="fc" id="L95">                return s1.getSequenceNumber().compareTo(s2.getSequenceNumber());</span>
            }
<span class="fc" id="L97">            return priority;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>